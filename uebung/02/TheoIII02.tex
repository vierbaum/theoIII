\documentclass{article}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{amsmath, amsfonts}
\usepackage{enumerate}
\usepackage{makecell}
\usepackage{xypic}
\input{title.tex}

\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\begin{document}
	\maketitle
	\section{}
	\begin{enumerate}[a)]
		\item
		    Für diese Aufgabe nehmen wir an, dass der Index $i$
			des zu ändernden bzw zu löschenden Elements gegeben ist.
			Ist nur der Wert gegeben, ist Suche von linearer Laufzeit
			anzuwenden.
			Unter der Annahme, dass wir auf einem Min-Heap arbeiten ist
			\begin{itemize}
				\item
				    \textbf{Wert ändern:}\\
					Um den Wert des Elements mit Index $i$ auf $w$ zu ändern
					gehen wir for wie folgt:
					\begin{enumerate}[1.]
						\item
    						Aktualisieren: wir weisen dem Element mit index $i$ den wert $w$ zu.
						\item
    						Heap-Eigenschaft wiederherstellen: Da die Änderung die Heap-Eigenschaft verletzen könnte.
						    Wir betrachten folgende Fälle:
							\begin{enumerate}[\text{Fall} 1:]
								\item
    								$w <$ ursprünglicher wert. Wir führen einen sog. ``Bubble up'' durch.
                                    \begin{enumerate}[1]
                                        \item Vergleiche A[$i$] mit Vater A[parent($i$)]
                                        \item ist A[$i$] $<$ A[parent($i$)], tausche A[$i$], A[parent($i$)]
                                        \item Wiederhole, bis 2 nicht mehr gilt
                                    \end{enumerate}
								\item
    								$w >$ ursprünglicher wert. Wir führen einen sog. ``Bubble down'' durch.
                                    \begin{enumerate}[1]
                                        \item Vergleiche A[$i$] mit Kindern A[leftchildr$(i)$],  A[rightchild$(i)$]
                                        \item finde das Kleinste kind $m:=\min\{A[\text{leftchildr}(i)],  A[\text{rightchild}(i)]\}$
                                        \item ist $m < w$, tausche $A[i]$, mit dem Kleinsten Kind.
                                        \item Wiederhole, bis 3 nicht mehr gilt
                                    \end{enumerate}
							\end{enumerate}
                    \end{enumerate}
                    Laufzeit: Sowohl bei bubble up, wie auch bei bubble down gibt es maximal so viele vertauschungen, wie der Baum
                    hoch ist. Demnach ist Wert ändern unter Annahmen, dass der Index des Wertes vorher bekannt ist in $\log(n)$.
                \item
                    \textbf{Element Löschen}
                    \begin{enumerate}[1.]
                        \item
                            Tauschen: Wir Nehmen das letzte Element im Heap (Visuell rechts auf der Untersten ebene)
                            mit Index $k$ und setzen $A[i]:=A[k]$
                        \item
                            Entfernen: Wir verkleinern den Heap um 1. So entfernen wir das Element $A[k]$
                        \item
                            Heap-Eigenschaft wiederherstellen: Das neue Element bei $A[i]$ könnte die
                            Heap-Eigenschaft verletzen. Wir prüfen wie bei Wert ändern beschrieben, ob
                            Sift-up bzw. Sift-down notwendig sind und führen diese durch.
                    \end{enumerate}
                    Laufzeit: Diese Operation besteht aus einem Tausch ($O(1)$), einer Verringerung der Größe des Heaps
                    ($O(1)$) und einem Sift-up oder einem Sift-down ($O(\log n)$). Demnach ist Element löschen
                    in $O(\log n)$
            \end{itemize}
		\item
		    Wir wissen, dass $\log x$ auf $x>0$ monoton
			steigt.
			Demnach gilt
			\begin{equation*}
				\sum_{i=1}^n \log i\leq
				\sum_{i=1}^n \log n=n\log n
            \end{equation*}
            Weiter ist
            \begin{align*}
                \limsup\limits_{n\in\N^+}
                \frac{\sum_{i=1}^n\log i}{n\log n}
                \leq
                \limsup\limits_{n\in\N^+}
                \frac{n\log n}{n\log n}
                =1<\infty
            \end{align*}
            Es gilt
            \begin{equation*}
                \sum_{i=1}^n \log i\in O(n\log n)
            \end{equation*}

            Es gilt $0<\log k<\log n(1<k<n)$ und demnach
            gilt
            \begin{equation*}
                \underset{k<n\in\N^+}\forall\,
                \underset{a>1}\exists
                a\log(k)=\log(n)
            \end{equation*}
            Wir definieren $a_k$ mit
            \begin{equation*}
                a_k = \frac{\log n}{\log k}.
            \end{equation*}
            Somit gilt
            \begin{align*}
                \liminf\limits_{n\in\N^+}
                \frac{\sum_{i=1}^n\log i}{n\log n}
                &=
                \liminf\limits_{n\in\N^+}
                \frac{1\cdot\log n+a_{n-1}\log n+\hdots+a_1\log n}{\log n}\\
                &=
                \liminf\limits_{n\in\N^+}
                \frac{\log n(1+a_{n-1}+\hdots+a_1)}{n\log n}\\
                &=
                \liminf\limits_{n\in\N^+}
                \frac{1+a_{n-1}+\hdots+a_1}{n}\\
                &\geq
                \liminf\limits_{n\in\N^+}
                \frac{\sum_{k=1}^n 1}{n}\\
                &=1>0
            \end{align*}
            Demnach gilt $\sum_{i=1}^n\log i\in\Omega(n\log n)$
            und $\sum_{i=1}^n\log i\in\Theta(n\log n)$
    \end{enumerate}
    \section{}
    \xymatrix{
        &&&&1\ar[dll]\ar[drr]\\
        &&2\ar[dl]\ar[dr]&&&&3\ar[dl]\ar[dr]\\
        &4\ar[dl]\ar[dr]&&5&&6&&7\\
        \vdots&&\ddots
    }
    Dann gilt für knoten $n$, die linke kante $(n,2n)$
    und die rechte $(n,2n+1)$
    und für beliebigen knoten $m$ der
    $k$ mal rechts von $n$ liegt ist
    $m=2^k+\sum_{i=0}^{k-1}2^i$
    Somit ist
    Also ist für beliebigen knoten $n$ links-rechts-$\hdots$
    $=A_n=\{(n,2n),(2n\cdot \left[2^k+\sum_{i=0}^{k-1}2^i\right],2n\cdot \left[2^{k+1}+\sum_{i=0}^{k}2^i)\right]|k>1\}$
    Wir nehmen an, es existieren $n\neq m$ mit
    $A_n\cap A_m\neq\emptyset$.
    Dann gilt
    \begin{align*}
    	&\{(n,2n),(2n\cdot \left[2^k+\sum_{i=0}^{k-1}2^i\right],2n\cdot \left[2^{k+1}+\sum_{i=0}^{k}2^i)\right]|k>1\}\\
    	\cap&\{(m,2m),(2m\cdot \left[2^k+\sum_{i=0}^{k-1}2^i\right],2m\cdot \left[2^{k+1}+\sum_{i=0}^{k}2^i)\right]|k>1\}\neq\emptyset\\
        \Leftrightarrow&\underset{j,k>1}\exists:
        2n\cdot \left[2^k+\sum_{i=0}^{k-1}2^i\right]
        =2m\cdot \left[2^j+\sum_{i=0}^{j-1}2^i\right]\\
        \Leftrightarrow&\underset{j,k>1}\exists:
        \frac{n}{m}\cdot \left[2^k+\sum_{i=0}^{k-1}2^i\right]
        =\left[2^j+\sum_{i=0}^{j-1}2^i\right]\tag 1\\
        \Leftrightarrow&\underset{j,k>1}\exists:
        \left[2^k+\sum_{i=0}^{k-1}2^i\right]
        =\frac{m}{n}\cdot \left[2^j+\sum_{i=0}^{j-1}2^i\right]\tag 2\\
    \end{align*}
    Da die summen ganzzahlig sind, folgt aus (1) $m$ tilt
    $n$ und aus $2$ folgt $n$ teilt $m$, also
    ist $n=m$, das ist ein widerspruch zur annahme

    Ist bspw. links-links-rechts-rechts-$hdots$
    ist $A_1\cap A_2=\{(2,4)\}$
    \section{}
    \paragraph{Adjazenzmatrix}
    $|V|\times|V|$ Matrix wobei
    $M_{uv}$ angibt, ob es eine kante $(u,v)$ gibt.

    Gibt es eine Kante $(u,v):O(1)$

    Über Kanten iterieren: $O(|V|)$
    \paragraph{Inzidenzmatrix}
    $|V|\times |E|$ Matrix,

    wobei $M_{ux}=1\Leftrightarrow$ Knoten $u$ ist teil von Kante $x$

    Gibt es eine Kante $(u,v):O(|E|)$

    Über Kanten iterieren: $O(|E|)$
    \paragraph{Adjazenzliste}
    Jedem Knoten $u$ wird eine Meinge an Nachbarn
    zugewiesen mit $\{v\in V|(u,v)\in E\}$

    Gibt es eine Kante $(u,v):O(|V|)$

    Über Kanten iterieren: $O(|V|)$
    \section{}
    \paragraph{Reflexivität}
    Da der Pfad von $a$ nach $a$ existiert
    ist $aRa$
    \paragraph{Symmetrie}
    ist $aRb$ existiert ein pfad von $a$ nach $b$
    und von $b$ nach $a$
    also gilt  $bRa$
    \paragraph{Transitivität}
    Seien $a,b,c$ 3 Knoten mit
    $aRb$ und $bRc$.
    Also existieren ein Pfade
    $\pi_0=a\hdots b,\pi_1=b\hdots c$.
    Demnach existieren Pfade $\pi_3=\pi_0\pi_1=a\hdots c,
    \pi_3'=c\hdots a$ und es ist $aRc$ also
    ist $R$ eine Äquivalenzrelation.

    ist $a\rightarrow b$, so gilt
    $\underset{u\in[a]}u\rightarrow b$ da $u\rightarrow a\rightarrow b$
    ist nun $a\rightarrow b\rightarrow c$, gilt
    $\underset{u\in[a]\cup[b]}u\rightarrow b$
    und ist $a\rightarrow b\rightarrow c\rightarrow a$, gilt
    $\underset{u\in[a]\cup[b]\cup[c]}u\rightarrow a\land a\rightarrow u$,
    denn ist
    \begin{enumerate}
        \item $u\in[a]\Leftrightarrow a\sim u$,
        \item $u\in[b]\Leftrightarrow a\rightarrow b\rightarrow u(u\sim b)$
        \item $u\in[c]\Leftrightarrow a\rightarrow b\rightarrow c\rightarrow u(u\sim c)$
    \end{enumerate}
    Demnach gilt $u\sim a$, $a\sim b\sim c$ und $[a]=[b]=[c]$
\end{document}
